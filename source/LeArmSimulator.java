/* autogenerated by Processing revision 1294 on 2025-01-22 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import com.jogamp.newt.opengl.GLWindow;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class LeArmSimulator extends PApplet {



// controls
CameraControl cam;


Arm myArm;


//UI
PFont UIFont;
int ui_font_size = 25;
ArrayList<TextBox> tb_list = new ArrayList<TextBox>();


public void setup() {
  /* size commented out by preprocessor */;
  // font setup
  UIFont = createFont("Consolas", ui_font_size);
  textFont(UIFont);
  
  cam = new CameraControl(this);
  myArm = new Arm();
  
  // UI stuff
  // x y width height
  for (int i = 1; i <= 6; i++){
    TextBox newServ = new TextBox(width - 70, height - (50 * i), 100, 20, ui_font_size);
    tb_list.add(newServ);
  }
  /*
  Slider test_s = new Slider();
  println(test_s.getValuePercent());
  */
}

public void draw() {
  background(0);
  perspective();
  
  stroke(255, 100, 100);
  line(-500, 0, 0, 500, 0, 0);
  line(0, -500, 0, 0, 500, 0);
  line(0, 0, -500, 0, 0, 500);
  noStroke();
  stroke(255, 200, 200);
  myArm.drawArm();
  //camera(60, height/2.5, (height/8), 0, height/2, 0, 0, 1, 0);
  
  UIDrawControl();
}

public void mousePressed(){
  for (TextBox servo_ui : tb_list){
    servo_ui.checkFocus();
    if (servo_ui.focused && cam.enabled){
      cam.enabled = false;
    }
    else if (!servo_ui.focused && !cam.enabled){
      cam.enabled = true;
    }
  }
}

public void UIDrawControl(){
  // hud
  pushMatrix();
  ortho();
  resetMatrix();
  rectMode(LEFT);
  textAlign(LEFT);
  translate(-width/2.0f, -height/2.0f);
  hint(DISABLE_DEPTH_TEST);
  fill(255);
  text("[UP],[DOWN] : Tilt up/down", 20, height - 20);
  text("[LEFT],[RIGHT] : Pan left/right", 20, height - 50);
  text("[w],[s] : Move forward/backward", 20, height - 80);
  text("[a],[d] : Move left/right", 20, height - 110);
  text("[e],[c] : Move up/down", 20, height - 140);
  text("[h] to update arm", 20, height - 170);
  text("Servo Limits: 500-2500", 10, 30);
  hint(ENABLE_DEPTH_TEST);
  popMatrix();
  
  // UI
  for (TextBox servo_ui : tb_list){
    servo_ui.drawTextBox();
    //servo_ui.drawTextBox();
  }
}

public void keyPressed(){
  for (TextBox servo_ui : tb_list){
    if (servo_ui.focused){
      servo_ui.editText();
      if (key == ENTER){
        cam.enabled = true;
      }
    }
  }
  if (key == 'h' && cam.enabled){
    for (int i = 0; i <= 5; i++){
      int ui_value = tb_list.get(i).getValue();
      updateMotor(i, ui_value);
    }
  }
  
}

// make rotation inputs match what arm should be
public void updateMotor(int index, int value){
  if (myArm.rotation_range[0] <= value && value <= myArm.rotation_range[1]){
    myArm.action(index, value);
  }
}
// sizes of each arm piece
float[] size_pl = {0, 0, 0};
float[] size_seg6_5 = {50, 50, 50};
float[] size_seg5_4 = {10, 50, 25};
float[] size_seg4_3 = {10, 45, 15};
float[] size_seg3_2 = {10, 25, 25};
float[] size_seg2_1 = {15, 15, 5};
float[] size_seg1 = {5, 20, 7};
float[] size_seg1base = {15, 15, 20};

//initial position values for each arm piece
mathFinder mf = new mathFinder();
float[] pos_pl = {0, 0, 0};
float[] pos_seg6_5 = {0, 0, 0};
float[] pos_seg5_4 = {0, mf.getPosY(pos_seg6_5, size_seg6_5, size_seg5_4), 0};
float[] pos_seg4_3 = {0, mf.getPosY(pos_seg5_4, size_seg5_4, size_seg4_3), 0};
float[] pos_seg3_2 = {0, mf.getPosY(pos_seg4_3, size_seg4_3, size_seg3_2), 0};
float[] pos_seg2_1 = {0, mf.getPosY(pos_seg3_2, size_seg3_2, size_seg2_1), 0};
float[] pos_seg1base = {0, mf.getPosY(pos_seg2_1, size_seg2_1, size_seg1base), 0};
float[] pos_seg1 = {0, mf.getPosY(pos_seg1base, size_seg1base, size_seg1), 0};

float[][] all_size = {size_pl, size_seg6_5, size_seg5_4, size_seg4_3, size_seg3_2, size_seg2_1, size_seg1, size_seg1base};
float[][] all_pos = {pos_pl, pos_seg6_5, pos_seg5_4, pos_seg4_3, pos_seg3_2, pos_seg2_1, pos_seg1, pos_seg1base}; 


class mathFinder{
  public float getPosY(float[] prev_seg_pos, float[] prev_seg_size, float[] seg_size){
    return prev_seg_pos[1] - (prev_seg_size[1] / 2) - (seg_size[1] / 2);
  }
  
  public float[] getArmPiecePos(ArmPiece parent, ArmPiece child){
    float x_child = sin(child.total_rotation[2]) * (child.size[1] / 2) + sin(parent.total_rotation[2]) * (parent.size[1] / 2);
    float y_child = - cos(child.total_rotation[2]) * (child.size[1] / 2) - cos(parent.total_rotation[2]) * (parent.size[1] / 2);
    float z_child = sin(child.total_rotation[1]) * (x_child);
    x_child *= cos(child.total_rotation[1]);
    float x = x_child + parent.x;
    float y = y_child + parent.y;
    float z = -z_child + parent.z;
    float[] final_pos = {x, y, z};
    
    return final_pos;
  }
  
  public float[] getArmPinchersPos(ArmPiece parent, ArmPinchers child){
    float x_child = sin(child.total_rotation[2]) * (child.size[1] / 2) + sin(parent.total_rotation[2]) * (parent.size[1] / 2);
    float y_child = - cos(child.total_rotation[2]) * (child.size[1] / 2) - cos(parent.total_rotation[2]) * (parent.size[1] / 2);
    float z_child = sin(child.total_rotation[1]) * (x_child);
    x_child *= cos(child.total_rotation[1]);
    float x_difference = sin(parent.total_rotation[1]) * ((parent.size[2] / 2));
    float z_difference = cos(parent.total_rotation[1]) * ((parent.size[2] / 2));
    float x = x_child + parent.x;
    float y = y_child + parent.y;
    float z = -z_child + parent.z;
    float[] final_pos = {x + x_difference, y, z + z_difference, x - x_difference, y, z - z_difference};
    
    return final_pos;
  }
}


class ArmPiece{
  float x = 0;
  float y = 0;
  float z = 0;
  float[] size = {10, 10, 10};
  float[] rotation = {0, 0, 0};
  float[] total_rotation = {0 ,0, 0};
  float[] rotation_range = {500, 2500};
  ArmPiece parent;
  int rotation_dir = 2;
  boolean moved = false;

  public ArmPiece(float x, float y, float z, float[] size, float[] rotation, ArmPiece parent, int rotation_dir){
    this.x = x;
    this.y = y;
    this.z = z;
    this.size = size;
    this.rotation[0] = rotation[0];
    this.rotation[1] = rotation[1];
    this.rotation[2] = rotation[2];
    this.parent = parent;
    this.rotation_dir = rotation_dir;
  }
  
  public void drawPiece(){
    if (this.parent.moved | this.moved){
      float[] r = {this.parent.total_rotation[0] + this.rotation[0], this.parent.total_rotation[1] + this.rotation[1], this.parent.total_rotation[2] + this.rotation[2]};
      this.total_rotation = r;
      this.moved = true;
      this.parent.moved = false;
    }
    pushMatrix();
    float[] piece_pos = mf.getArmPiecePos(this.parent, this);
    this.x = piece_pos[0];
    this.y = piece_pos[1];
    this.z = piece_pos[2]; //<>//
    translate(this.x, this.y, this.z);
    rotateX(this.total_rotation[0]);
    rotateY(this.total_rotation[1]);
    rotateZ(this.total_rotation[2]);
    fill(100);
    box(this.size[0], this.size[1], this.size[2]);
    popMatrix();
  }
  
  public void move(float to_angle){
    // don't bother moving if angle is the same
    if (this.rotation[this.rotation_dir] == to_angle){
      return;
    }
    this.rotation[this.rotation_dir] = to_angle;
    this.moved = true;
  }
}


class ArmPieceBuilder{
  private float x = 0;
  private float y = 0;
  private float z = 0;
  private float[] size = {10, 10, 10};
  private float[] rotation = {0, 0, 0};
  private float[] rotation_range = {500, 2500};
  private ArmPiece parent;
  private int rotation_dir = 2;
  
  public ArmPieceBuilder(float x, float y, float z, float[] size, float[] rotation){
    this.x = x;
    this.y = y;
    this.z = z;
    this.size = size;
    this.rotation = rotation;
  }
  
  public ArmPieceBuilder setParent(ArmPiece parent){
    this.parent = parent;
    return this;
  }
  
  public ArmPieceBuilder setRotationDir(int rotation_dir){
    this.rotation_dir = rotation_dir;
    return this;
  }
  
  public ArmPiece build(){
    return new ArmPiece(x, y, z, size, rotation, parent, rotation_dir);
  }
}


class ArmPinchers extends ArmPiece{
  ArmPiece piece1;
  ArmPiece piece2;

  public ArmPinchers(float x, float y, float z, float[] size, float[] rotation, ArmPiece parent, int rotation_dir){
    super(x, y, z, size, rotation, parent, rotation_dir);
    piece1 = new ArmPieceBuilder(x, y, z + (parent.size[2] / 2) + (size[2] / 2), size, rotation).setParent(parent).setRotationDir(rotation_dir).build();
    piece2 = new ArmPieceBuilder(x, y, z - (parent.size[2] / 2) - (size[2] / 2), size, rotation).setParent(parent).setRotationDir(rotation_dir).build();
  }
  
  public void drawPiece(){
    if (this.parent.moved | this.moved){
      float[] r = {this.parent.total_rotation[0] + this.rotation[0], this.parent.total_rotation[1] + this.rotation[1], this.parent.total_rotation[2] + this.rotation[2]};
      this.total_rotation = r;
      this.moved = true;
      this.parent.moved = false;
      this.piece1.total_rotation = r;
      this.piece2.total_rotation = r;
    }
    float[] piece_pos = mf.getArmPinchersPos(this.parent, this);
    pushMatrix();
    this.x = piece_pos[0];
    this.y = piece_pos[1];
    this.z = piece_pos[2];
    translate(this.x, this.y, this.z);
    rotateX(this.total_rotation[0]);
    rotateY(this.total_rotation[1]);
    rotateZ(this.total_rotation[2]);
    fill(100);
    box(this.size[0], this.size[1], this.size[2]);
    popMatrix();
    
    pushMatrix();
    this.x = piece_pos[3];
    this.y = piece_pos[4];
    this.z = piece_pos[5];
    translate(this.x, this.y, this.z);
    rotateX(-this.total_rotation[0]);
    rotateY(this.total_rotation[1]);
    rotateZ(this.total_rotation[2]);
    fill(100);
    box(this.size[0], this.size[1], this.size[2]);
    popMatrix();
  }
  
  public void move(float to_angle){
    this.rotation[this.rotation_dir] = to_angle;
    this.moved = true;
  }
}


class ArmPinchersBuilder{
  private float x = 0;
  private float y = 0;
  private float z = 0;
  private float[] size = {10, 10, 10};
  private float[] rotation = {0, 0, 0};
  private float[] rotation_range = {500, 2500};
  private ArmPiece parent;
  private int rotation_dir = 2;
  
  public ArmPinchersBuilder(float x, float y, float z, float[] size, float[] rotation){
    this.x = x;
    this.y = y;
    this.z = z;
    this.size = size;
    this.rotation = rotation;
  }
  
  public ArmPinchersBuilder setParent(ArmPiece parent){
    this.parent = parent;
    return this;
  }
  
  public ArmPinchersBuilder setRotationDir(int rotation_dir){
    this.rotation_dir = rotation_dir;
    return this;
  }
  
  public ArmPinchers build(){
    return new ArmPinchers(x, y, z, size, rotation, parent, rotation_dir);
  }
}


class Arm{
  float[] start_rotation = {0, 0, 0};
  float[] pl_rotation = {0, 0, 0};
  float[] rotation_range = {500, 2500};
  // placeholder arm for pieces that don't need
  ArmPiece placeholder = new ArmPieceBuilder(pos_pl[0], pos_pl[1], pos_pl[2], size_pl, pl_rotation).build();
  // create pieces of arm
  ArmPiece base = new ArmPieceBuilder(pos_seg6_5[0], pos_seg6_5[1], pos_seg6_5[2], size_seg6_5, start_rotation).setParent(placeholder).setRotationDir(1).build();
  ArmPiece s5_4 = new ArmPieceBuilder(pos_seg5_4[0], pos_seg5_4[1], pos_seg5_4[2], size_seg5_4, start_rotation).setParent(base).build();
  ArmPiece s4_3 = new ArmPieceBuilder(pos_seg4_3[0], pos_seg4_3[1], pos_seg4_3[2], size_seg4_3, start_rotation).setParent(s5_4).build();
  ArmPiece s3_2 = new ArmPieceBuilder(pos_seg3_2[0], pos_seg3_2[1], pos_seg3_2[2], size_seg3_2, start_rotation).setParent(s4_3).build();
  ArmPiece s2_1 = new ArmPieceBuilder(pos_seg2_1[0], pos_seg2_1[1], pos_seg2_1[2], size_seg2_1, start_rotation).setParent(s3_2).setRotationDir(1).build();
  ArmPiece seg1base = new ArmPieceBuilder(pos_seg1base[0], pos_seg1base[1], pos_seg1base[2], size_seg1base, start_rotation).setParent(s2_1).build();
  ArmPinchers seg1 = new ArmPinchersBuilder(pos_seg1[0], pos_seg1[1], pos_seg1[2], size_seg1, start_rotation).setParent(seg1base).setRotationDir(0).build();
  
  ArmPiece[] pieces = {base, s5_4, s4_3, s3_2, s2_1, seg1, seg1base};
  
  public void drawArm(){
    for (ArmPiece piece : this.pieces){
      piece.drawPiece();
    }
  }
  
  public boolean action(int servo_index, float value){
    if (!(rotation_range[0] <= value && value <= rotation_range[1])){
      println("invalid rotation, range is", rotation_range[0], "-", rotation_range[1]);
      return false;
    }
    float median = (this.rotation_range[0] + this.rotation_range[1]) / 2;
    float value_percent = (median - value) / (rotation_range[1] - median);
    float angle = (PI / 2) * value_percent;
    this.pieces[servo_index].move(angle);
    return true;
  }
  
}
public class CameraControl {
  final float MOVE_SPEED = 8;
  final float ROTATION_SPEED = 0.02f;
  boolean enabled = true;
  
  PApplet parent;

  CameraControl(PApplet parent) {
    this.parent = parent;
    try {
      parent.registerMethod("dispose", this);
      parent.registerMethod("pre", this);
    } 
    catch (Exception e) {
    }
  }

  public void dispose() {
    parent.unregisterMethod("dispose", this);
    parent.unregisterMethod("pre", this);
  }

  public void pre() {
    // If you don't wont to run automatically, comment out this line and call keyControl() in the draw() instead.
    keyControl();
  }

  public void keyControl() {
    if (!this.enabled){
      return;
    }
    if ( !parent.keyPressed ) return;

    // Matrix that modifies the camera matrix
    PMatrix3D M = new PMatrix3D();

    if ( parent.key == 'w' ) {
      M.translate( 0, 0, MOVE_SPEED );
    } else if ( parent.key == 's' ) {
      M.translate( 0, 0, -MOVE_SPEED );
    } else if ( parent.key == 'a' ) {
      M.translate( MOVE_SPEED, 0, 0 );
    } else if ( parent.key == 'd' ) { 
      M.translate( -MOVE_SPEED, 0, 0 );
    } else if ( parent.key == 'e' ) { 
      M.translate( 0, MOVE_SPEED, 0 );
    } else if ( parent.key == 'c' ) { 
      M.translate( 0, -MOVE_SPEED, 0 );
    } else if ( parent.key == PConstants.CODED ) {
      if ( parent.keyCode == PConstants.UP ) {     
        M.rotateX(ROTATION_SPEED);
      } else if ( parent.keyCode == PConstants.DOWN ) {  
        M.rotateX(-ROTATION_SPEED);
      } else if ( parent.keyCode == PConstants.RIGHT ) { 
        M.rotateY(ROTATION_SPEED);
      } else if ( parent.keyCode == PConstants.LEFT ) {  
        M.rotateY(-ROTATION_SPEED);
      }
    }

    // Modify the current camera matrix
    PMatrix3D C = ((PGraphicsOpenGL)(this.parent.g)).camera.get(); // copy
    C.preApply(M);

    // Correction to make the up vector to (0,1,0)
    C.invert();
    float ex = C.m03;
    float ey = C.m13;
    float ez = C.m23;
    float cx = -C.m02 + ex;
    float cy = -C.m12 + ey;
    float cz = -C.m22 + ez;
    parent.camera( ex, ey, ez, cx, cy, cz, 0, 1, 0 );
  }
}
class Slider{
  int value = 1500;
  int[] value_range = {500, 2500};
  // x, y on screen
  float[] screen_pos = {100, 100};
  float w = 50;
  float h = 50;
  SliderDragBox sliding_box = new SliderDragBox(screen_pos[0], screen_pos[1], w / 10, h);
  SliderBackground sliding_bg = new SliderBackground(screen_pos[0], screen_pos[1], w, h);

  public float getValuePercent(){
    // median is needed because arm works where anything 500-1500 is one direction and 1500-2500 is the other
    float median = (this.value_range[0] + this.value_range[1]) / 2;
    float value_percent = (value - median) / (value_range[1] - median);
    return value_percent;
  }
  
  public void drawSlider(){
    this.sliding_box.drawDragBox();
    this.sliding_bg.drawBackground();
  }

}


class SliderDragBox{
  float x = 0;
  float y = 0;
  float w = 5;
  float h = 10;
  
  public SliderDragBox(float x, float y, float w, float h){
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
  }
  
  public void drawDragBox(){
    pushMatrix();
    ortho();
    resetMatrix();
    rectMode(CENTER);
    rect(this.x, this.y, this.w, this.h);
    popMatrix();
  }
}


class SliderBackground{
  float x = 0;
  float y = 0;
  float w = 0;
  float h = 0;

  public SliderBackground(float x, float y, float w, float h){
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
  }
  
  public void drawBackground(){
    pushMatrix();
    ortho();
    resetMatrix();
    rectMode(CENTER);
    // center line (slider along here)
    rect(this.x + (this.w / 2), this.y, this.w, this.h / 5);
    // left bounding box
    rect(this.x, this.y, this.w / 10, this.h);
    // right bounding box
    rect(this.x + this.w, this.y, this.w / 10, this.h);
    popMatrix();
    
  }
}


class TextBox{
  float x = 0;
  float y = 0;
  float w = 0;
  float h = 0;
  String text = "1500";
  int font_size = 12;
  boolean focused = false;
  
  public TextBox(float x, float y, float w, float h, int font_size){
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
    this.font_size = font_size;
  }
  
  public int getValue(){
    int output = Integer.parseInt(this.text);
    return output;
  }
  
  public void checkFocus(){
      // if mouse not within x boundary
    if ((this.x - this.w / 2) <= mouseX && mouseX <= (this.x + this.w / 2)){
      // if mouse not within y boundary
      if ((this.y - this.h / 2) <= mouseY && mouseY <= (this.y + this.h / 2)){
        this.focused = true;
        return;
      }
    }
    this.focused = false;
  }
  
  public void editText(){
    // if mouse isnt pressed box isnt edited
    if (!focused){
      return;
    }
    // this code executes if mouse is within boundary
    // if backspace
    if (key == BACKSPACE){
      if (this.text != null && this.text.length() > 0) {
        this.text = this.text.substring(0, this.text.length() - 1);
      }
    }
    // if enter lose focus
    else if (key == ENTER){
      this.focused = false;
    }
    
    // if numbers entered, add to string
    else if ((48 <= key) && (key <= 57)){
      this.text = this.text + key;
    }
  }
  
  public void drawTextBox(){
    this.w = this.text.length() * 7 * (this.font_size / 8);
    if (this.text.length() == 1){
      this.w += 2;
    }
    if (this.text.length() <= 0 ){
      return;
    }
    this.h = (this.font_size / 4) + this.font_size;
    pushMatrix();
    resetMatrix();
    rectMode(CENTER);
    textAlign(CENTER, CENTER);
    ortho();
    translate(-width/2.0f, -height/2.0f);
    // text(str, x, y, w, h)
    fill(155);
    rect(this.x, this.y, this.w, this.h);
    fill(255);
    text(this.text, this.x, this.y, this.w, this.h);
    popMatrix();
  }
}


  public void settings() { size(1200, 900, P3D); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "LeArmSimulator" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
